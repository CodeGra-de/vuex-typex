{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import { ActionTree, GetterTree, Module, ModuleTree, MutationTree, Plugin, Store, StoreOptions } from \"vuex\";\r\n\r\nconst useRootNamespace = { root: true }\r\n\r\nexport type MutationHandler<S, P> = (state: S, payload: P) => void\r\nexport type ActionHandler<S, R, G, P, T> = (context: BareActionContext<S, R, G>, payload: P) => Promise<T> | T\r\nexport type GetterHandler<S, R, G, T> = (state: S, getters: G, rootState: R) => T\r\n\r\n\r\ninterface Dictionary<T> { [key: string]: T }\r\ninterface RootStore<R> extends Store<R> { rootGetters?: any }\r\n\r\nexport interface BareActionContext<S, R, G=any>\r\n{\r\n    state: S\r\n    rootState: R\r\n    getters: G\r\n}\r\n\r\nclass ModuleBuilderImpl<S, R={}, G=any> implements ModuleBuilder<S, R> {\r\n    protected _store: RootStore<R> | undefined\r\n\r\n    protected _getters: GetterTree<S, R> = {}\r\n    protected _mutations: MutationTree<S> = {}\r\n    protected _actions: ActionTree<S, R> = {}\r\n    protected _moduleBuilders: Dictionary<ModuleBuilder<any, R>> = {}\r\n\r\n    protected _vuexModule: Module<S, R> | undefined\r\n\r\n    constructor(public readonly namespace: string, private _initialState: S | null) { }\r\n\r\n    state(): () => S\r\n    {\r\n        if (!this.namespace)\r\n        {\r\n            return () => <any>this._store!.state as S\r\n        }\r\n        else if (this.namespace.indexOf(\"/\") < 0)\r\n        {\r\n            return () => (<any>this._store!.state)[this.namespace] as S\r\n        }\r\n        else\r\n        {\r\n            const namespaces = this.namespace.split(\"/\")\r\n            return () =>\r\n            {\r\n                let accessor: any = this._store!.state\r\n                for (const name of namespaces)\r\n                {\r\n                    accessor = accessor[name]\r\n                }\r\n                return (<any>accessor) as S\r\n            }\r\n        }\r\n    }\r\n\r\n    setInitialState(initialState: S): void\r\n    {\r\n        this._initialState = initialState\r\n    }\r\n\r\n    module<M>(namespace: string, initialState: M): ModuleBuilder<M, R>\r\n    module<M>(namespace: string): ModuleBuilder<M, R>\r\n    module<M>(namespace: string, initialState?: M): ModuleBuilder<M, R>\r\n    {\r\n        const existingModule = this._moduleBuilders[namespace]\r\n        const qualifiedNamespace = qualifyNamespace(this.namespace, namespace)\r\n        if (!initialState && existingModule)\r\n        {\r\n            return existingModule\r\n        }\r\n\r\n        // both arguments: create a module        \r\n        if (existingModule && initialState)\r\n        {\r\n            existingModule.setInitialState(initialState)\r\n            return existingModule\r\n        }\r\n\r\n        const nestedBuilder = new ModuleBuilderImpl<M, R>(qualifiedNamespace, initialState || null)\r\n        this._moduleBuilders[namespace] = nestedBuilder\r\n        return nestedBuilder\r\n    }\r\n\r\n    commit<P>(handler: MutationHandler<S, void>): () => void\r\n    commit<P>(handler: MutationHandler<S, P>): (payload: P) => void\r\n    commit<P>(handler: MutationHandler<S, void>, name: string): () => void\r\n    commit<P>(handler: MutationHandler<S, P>, name: string): (payload: P) => void\r\n    commit<P>(handler: MutationHandler<S, P>, name?: string)\r\n    {\r\n        const { key, namespacedKey } = qualifyKey(handler, this.namespace, name)\r\n        if (this._mutations[key])\r\n        {\r\n            throw new Error(`There is already a mutation named ${key}.`)\r\n        }\r\n        this._mutations[key] = handler\r\n        return ((payload: P) => this._store!.commit(namespacedKey, payload, useRootNamespace)) as any\r\n    }\r\n\r\n    dispatch<P, T>(handler: ActionHandler<S, R, G, void, void>): () => Promise<void>\r\n    dispatch<P, T>(handler: ActionHandler<S, R, G, P, void>): (payload: P) => Promise<void>\r\n    dispatch<P, T>(handler: ActionHandler<S, R, G, void, T>): () => Promise<T>\r\n    dispatch<P, T>(handler: ActionHandler<S, R, G, P, T>): (payload: P) => Promise<T>\r\n    dispatch<P, T>(handler: ActionHandler<S, R, G, void, void>, name: string): () => Promise<void>\r\n    dispatch<P, T>(handler: ActionHandler<S, R, G, P, void>, name: string): (payload: P) => Promise<void>\r\n    dispatch<P, T>(handler: ActionHandler<S, R, G, void, T>, name: string): () => Promise<T>\r\n    dispatch<P, T>(handler: ActionHandler<S, R, G, P, T>, name: string): (payload: P) => Promise<T>\r\n    dispatch<P, T>(handler: any, name?: string): any\r\n    {\r\n        const { key, namespacedKey } = qualifyKey(handler, this.namespace, name)\r\n        if (this._actions[key])\r\n        {\r\n            throw new Error(`There is already an action named ${key}.`)\r\n        }\r\n        this._actions[key] = handler\r\n        return (payload: P) => this._store!.dispatch(namespacedKey, payload, useRootNamespace)\r\n    }\r\n\r\n    read<T>(handler: GetterHandler<S, R, G, T>): () => T\r\n    read<T>(handler: GetterHandler<S, R, G, T>, name: string): () => T\r\n    read<T>(handler: GetterHandler<S, R, G, T>, name?: string): () => T\r\n    {\r\n        const { key, namespacedKey } = qualifyKey(handler, this.namespace, name)\r\n        if (this._getters[key])\r\n        {\r\n            throw new Error(`There is already a getter named ${key}.`)\r\n        }\r\n        this._getters[key] = handler\r\n        return () =>\r\n        {\r\n            if (this._store!.rootGetters)\r\n            {\r\n                return this._store!.rootGetters[namespacedKey] as T\r\n            }\r\n            return this._store!.getters[namespacedKey] as T\r\n        }\r\n    }\r\n\r\n    vuexModule(): Module<S, R>\r\n    {\r\n        if (!this._vuexModule)\r\n        {\r\n            // build nested modules recursively, if any\r\n            const modules: ModuleTree<R> = {}\r\n            for (const namespace of Object.keys(this._moduleBuilders))\r\n            {\r\n                modules[namespace] = this._moduleBuilders[namespace].vuexModule()\r\n            }\r\n\r\n            this._vuexModule = {\r\n                namespaced: true,\r\n                state: this._initialState || <S>{},\r\n                getters: this._getters,\r\n                mutations: this._mutations,\r\n                actions: this._actions,\r\n                modules\r\n            }\r\n        }\r\n        return this._vuexModule\r\n    }\r\n\r\n    _provideStore(store: Store<R>)\r\n    {\r\n        this._store = store\r\n\r\n        forEachValue(this._moduleBuilders, m => m._provideStore(store))\r\n    }\r\n}\r\n\r\nfunction qualifyKey(handler: Function, namespace: string | undefined, name?: string): { key: string, namespacedKey: string }\r\n{\r\n    const key: string = name || handler.name\r\n    if (!key)\r\n    {\r\n        throw new Error(`Vuex handler functions must not be anonymous. Possible causes: fat-arrow functions, uglify.  To fix, pass a unique name as a second parameter after your callback.`)\r\n    }\r\n    return { key, namespacedKey: qualifyNamespace(namespace, key) }\r\n}\r\n\r\nfunction qualifyNamespace(namespace: string | undefined, key: string)\r\n{\r\n    return namespace ? `${namespace}/${key}` : key\r\n}\r\n\r\nexport interface ModuleBuilder<S, R={}, G=any>\r\n{\r\n    /** The namespace of this ModuleBuilder */\r\n    readonly namespace: string\r\n\r\n    /** Creates a strongly-typed nested module within this module */\r\n    module<M>(namespace: string, initialState: M): ModuleBuilder<M, R>\r\n\r\n    /** Gets an existing nested module within this module */\r\n    module<M>(namespace: string): ModuleBuilder<M, R>\r\n\r\n    /** Set the initial state for an existing module */\r\n    setInitialState(initialState: S): void\r\n\r\n    /** Creates a strongly-typed commit function for the provided mutation handler */\r\n    commit<P>(handler: MutationHandler<S, void>): () => void\r\n    commit<P>(handler: MutationHandler<S, P>): (payload: P) => void\r\n    commit<P>(handler: MutationHandler<S, void>, name: string): () => void\r\n    commit<P>(handler: MutationHandler<S, P>, name: string): (payload: P) => void\r\n\r\n    /** Creates a strongly-typed dispatch function for the provided action handler */\r\n    dispatch<P, T>(handler: ActionHandler<S, R, G, void, void>): () => Promise<void>\r\n    dispatch<P, T>(handler: ActionHandler<S, R, G, P, void>): (payload: P) => Promise<void>\r\n    dispatch<P, T>(handler: ActionHandler<S, R, G, void, T>): () => Promise<T>\r\n    dispatch<P, T>(handler: ActionHandler<S, R, G, P, T>): (payload: P) => Promise<T>\r\n    dispatch<P, T>(handler: ActionHandler<S, R, G, void, void>, name: string): () => Promise<void>\r\n    dispatch<P, T>(handler: ActionHandler<S, R, G, P, void>, name: string): (payload: P) => Promise<void>\r\n    dispatch<P, T>(handler: ActionHandler<S, R, G, void, T>, name: string): () => Promise<T>\r\n    dispatch<P, T>(handler: ActionHandler<S, R, G, P, T>, name: string): (payload: P) => Promise<T>\r\n\r\n    /** Creates a strongly-typed read function for the provided getter function */\r\n    read<T>(handler: GetterHandler<S, R, G, T>): () => T\r\n    read<T>(handler: GetterHandler<S, R, G, T>, name: string): () => T\r\n\r\n    /** Creates a method to return this module's state */\r\n    state(): () => S\r\n\r\n    /** Output a Vuex Module definition. Called after all strongly-typed functions have been obtained */\r\n    vuexModule(): Module<S, R>\r\n\r\n    _provideStore(store: Store<R>): void\r\n}\r\n\r\nclass StoreBuilderImpl<R> extends ModuleBuilderImpl<any, R> {\r\n    constructor()\r\n    {\r\n        super(\"\", {})\r\n    }\r\n\r\n    module<S>(namespace: string, initialState: S): ModuleBuilder<S, R>\r\n    module<S>(namespace: string): ModuleBuilder<S, R>\r\n    module<S>(namespace: string, initialState?: S): ModuleBuilder<S, R>\r\n    {\r\n        return super.module(namespace, initialState) as ModuleBuilder<S, R>\r\n    }\r\n\r\n    vuexStore(): Store<R>\r\n    vuexStore(overrideOptions: StoreOptions<R>): Store<R>\r\n    vuexStore(overrideOptions: StoreOptions<R> = {}): Store<R>\r\n    {\r\n        if (!this._store)\r\n        {\r\n            const options: StoreOptions<R> & { namespaced?: boolean } = {\r\n                ...this.vuexModule(),\r\n                ...overrideOptions\r\n            }\r\n            const store = new Store<R>(options)\r\n            forEachValue(this._moduleBuilders, m => m._provideStore(store))\r\n            this._store = store\r\n        }\r\n        return this._store\r\n    }\r\n\r\n    registerModule(namespace: string): void\r\n    {\r\n        if (this._store && this._vuexModule) {\r\n            const mBuilder = this._moduleBuilders[namespace]\r\n            if (!mBuilder) throw 'fail to register module: ' + namespace\r\n            mBuilder._provideStore(this._store)\r\n\r\n            const vModule = mBuilder.vuexModule()\r\n            this._store.registerModule(namespace, vModule)\r\n\r\n            this._vuexModule.modules![namespace] = vModule\r\n        } else {\r\n            throw 'vuexStore hasn\\'t been called yet, use module() instead.'\r\n        }\r\n    }\r\n\r\n    reset()\r\n    {\r\n        this._store = undefined\r\n        this._moduleBuilders = {}\r\n    }\r\n}\r\n\r\nconst forEachValue = <T>(dict: Dictionary<T>, loop: (value: T) => any) =>\r\n{\r\n    Object.keys(dict).forEach(key => loop(dict[key]))\r\n}\r\n\r\nexport interface VuexStoreOptions<R>\r\n{\r\n    plugins?: Plugin<R>[]\r\n}\r\n\r\nexport interface StoreBuilder<R>\r\n{\r\n    /** Creates a ModuleBuilder for the namespace provided */\r\n    module<S>(namespace: string, state: S): ModuleBuilder<S, R>\r\n\r\n    /** Gets an existing ModuleBuilder for the namespace provided */\r\n    module<S>(namespace: string): ModuleBuilder<S, R>\r\n\r\n    /** Output a Vuex Store after all modules have been built */\r\n    vuexStore(): Store<R>\r\n\r\n    /** Output a Vuex Store and provide options, e.g. plugins -- these take precedence over any auto-generated options */\r\n    vuexStore(overrideOptions: StoreOptions<R>): Store<R>\r\n\r\n    /** Creates a strongly-typed commit function for the provided mutation handler */\r\n    commit<P>(handler: MutationHandler<R, void>): () => void\r\n    commit<P>(handler: MutationHandler<R, P>): (payload: P) => void\r\n    commit<P>(handler: MutationHandler<R, void>, name: string): () => void\r\n    commit<P>(handler: MutationHandler<R, P>, name: string): (payload: P) => void\r\n\r\n    /** Creates a strongly-typed dispatch function for the provided action handler */\r\n    dispatch<P, T>(handler: ActionHandler<R, R, void, void, void>): () => Promise<void>\r\n    dispatch<P, T>(handler: ActionHandler<R, R, void, P, void>): (payload: P) => Promise<void>\r\n    dispatch<P, T>(handler: ActionHandler<R, R, void, void, T>): () => Promise<T>\r\n    dispatch<P, T>(handler: ActionHandler<R, R, void, P, T>): (payload: P) => Promise<T>\r\n    dispatch<P, T>(handler: ActionHandler<R, R, void, void, void>, name: string): () => Promise<void>\r\n    dispatch<P, T>(handler: ActionHandler<R, R, void, P, void>, name: string): (payload: P) => Promise<void>\r\n    dispatch<P, T>(handler: ActionHandler<R, R, void, void, T>, name: string): () => Promise<T>\r\n    dispatch<P, T>(handler: ActionHandler<R, R, void, P, T>, name: string): (payload: P) => Promise<T>\r\n\r\n    /** Creates a strongly-typed read function for the provided getter function */\r\n    read<T>(handler: GetterHandler<R, R, void, T>): () => T\r\n    read<T>(handler: GetterHandler<R, R, void, T>, name: string): () => T\r\n\r\n    /** Creates a method to return the root state */\r\n    state(): () => R\r\n    \r\n    /** Dynamically register module */\r\n    registerModule(namespace: string): void\r\n\r\n    /** WARNING: Discards vuex store and reset modules (non intended for end-user use) */\r\n    reset(): void\r\n}\r\n\r\nconst storeBuilderSingleton = new StoreBuilderImpl<any>()\r\nconst namedStoreBuilderMap: { [name: string]: StoreBuilderImpl<any> } = Object.create(null)\r\n\r\n/** Get a reference to the default store builder */\r\nexport function getStoreBuilder<R>(): StoreBuilder<R>\r\n/** Get a reference to a named store builder */\r\nexport function getStoreBuilder<R>(name: string): StoreBuilder<R>\r\nexport function getStoreBuilder<R>(name?: string): StoreBuilder<R>\r\n{\r\n    // the default store builder\r\n    if (!name)\r\n    {\r\n        return storeBuilderSingleton\r\n    }\r\n\r\n    // a named store builder    \r\n    const builder = namedStoreBuilderMap[name] || (namedStoreBuilderMap[name] = new StoreBuilderImpl<R>())\r\n    return builder\r\n}\r\n"],"names":["Store"],"mappings":"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"}